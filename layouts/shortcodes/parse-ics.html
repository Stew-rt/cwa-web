{{/* parse‑ics.html – now handles recurrences */}}
{{ $path  := .Get "src" }}           {{/* e.g. "mycalendar.ics" */}}
{{ $raw   := resources.Get $path | .Content }}{{/* raw iCal text */}}
{{ $ical  := import "github.com/arran4/golang-ical" }}
{{ $rrule := import "github.com/teambition/rrule-go" }}

{{ $cal, err := $ical.ParseCalendar $raw }}
{{ if err }}
  {{ errorf "Failed to parse %s: %v" $path err }}
{{ end }}

{{/* Helper: convert a *time.Time* to YYYY‑MM‑DD string */}}
{{ $fmtDate := func $t -> (time.Format $t "2006-01-02") }}

{{ $events := slice }}

{{/* ----------------------------------------
   Loop over each VEVENT, expand recurrences if needed
   ---------------------------------------- */}}
{{ range $ev := $cal.Events }}
  {{ $uid      := $ev.GetProperty "UID" | default (dict "Value" "") | .Value }}
  {{ $summary  := $ev.GetProperty "SUMMARY" | default (dict "Value" "") | .Value }}
  {{ $desc     := $ev.GetProperty "DESCRIPTION" | default (dict "Value" "") | .Value }}
  {{ $dtStart  := $ev.GetStartAt }}   {{/* time.Time */}}
  {{ $dtEnd    := $ev.GetEndAt   }}

  {{/* --------------------------------------------------------
     1️⃣ If there is *no* RRULE → treat as a single‑occurrence event
     --------------------------------------------------------- */}}
  {{ if not ($ev.GetProperty "RRULE") }}
    {{ $events = $events | append (dict
       "uid"     $uid
       "summary" $summary
    "desc"    $desc
      "start"   ($fmtDate $dtStart)
       "end"     ($fmtDate $dtEnd)
      ) }}
    {{ continue }}
  {{ end }}

  {{/* -------------------------------------------------------
     2️⃣ There *is* an RRULE → build an rrule.RRule instance
     ----------------------------------------- */}}
  {{ $ruleStr := $ev.GetProperty "RRULE" | .Value }}   {{/* raw string */}}
  {{ $options := dict
      "Freq"   $rrule.DAILY   /* placeholder – will be overwritten */
      "Dtstart" $dtStart
    }}

/* -----------------------------------------------------------------
   Parse the RRULE string into a map of key/value pairs.
   The library expects a struct, so we fill it manually.
   ---------------------------------------------------------------- */
  {{ range $pair := split $ruleStr ";" }}
    {{ $kv := split $pair "=" }}
    {{ $k := index $kv 0 }}
    {{ $v := index $kv 1 }}

    {{/* Frequency --------------------------------------- */}}
    {{ if eq $k "FREQ" }}
      {{ $freqMap := dict
        "SECONDLY" $rrule.SECONDLY
          "MINUTELY" $rrule.MINUTELY
       "HOURLY"   $rrule.HOURLY
          "DAILY"    $rrule.DAILY
       "WEEKLY"   $rrule.WEEKLY
          "MONTHLY"  $rrule.MONTHLY
       "YEARLY"   $rrule.YEARLY
        }}
      {{ $options = merge $options (dict "Freq" (index $freqMap $v)) }}

    {{/* Interval -------------------------------------------------- */}}
    {{ else if eq $k "INTERVAL" }}
      {{ $options = merge $options (dict "Interval" (atoi $v)) }}

    {{/* Count ------------------------------------------------------ */}}
    {{ else if eq $k "COUNT" }}
      {{ $options = merge $options (dict "Count" (atoi $v)) }}

    {{/* Until ------------------------------------------------------ */}}
    {{ else if eq $k "UNTIL" }}
      {{ $until, _ := time.Parse "20060102T150405Z" $v }}
      {{ $options = merge $options (dict "Until" $until) }}

    {{/* ByDay ------------------------------------------------------ */}}
    {{ else if eq $k "BYDAY" }}
      {{ $byday := split $v "," }}
      {{ $options = merge $options (dict "Byweekday" $byday) }}

    {{/* ByMonthDay ------------------------------------------------- */}}
    {{ else if eq $k "BYMONTHDAY" }}
      {{ $bymd := split $v "," | apply "atoi" "." }}
      {{ $options = merge $options (dict "Bymonthday" $bymd) }}

    {{/* ByMonth ---------------------------------------------------- */}}
    {{ else if eq $k "BYMONTH" }}
      {{ $bym := split $v "," | apply "atoi" "." }}
      {{ $options = merge $options (dict "Bymonth" $bym) }}

    {{/* Anything else we just ignore – most rarely needed */}}
    { end }}
  {{ end }}

  {{/* Build the rule --------------------------------------------- */}}
  {{ $r, err := $rrule.NewRRule $options }}
  {{ if err }}
   {{ errorf "Failed to build rrule for %s: %v" $uid err }}
  {{ end }}

  {{/* ---------------------------------------
     3️⃣ Generate occurrences that land inside the target year.
         We’ll ask the caller for a `$year` param; if none is given,
         fall back to the start‑date’s year.
     ------------------------------------------------------------ */}}
  {{ $targetYear := .Get "year" | default (time.Format $dtStart "2006") | atoi }}
  {{ $yearStart := time.Parse (printf "%d-01-01" $targetYear) "2006-01-02" }}
  {{ $yearEnd   := time.Parse (printf "%d-12-31" $targetYear) "2006-01-02" }}

  {{ $ocurs := $r.Between $yearStart $yearEnd true }}

  {{/* ------------------------------------------------------------
     4️⃣ Emit a separate dict for each occurrence.
         End‑time is calculated by adding the original duration.
     ------------------------------------------------------------ */}}
  {{ $duration := $dtEnd.Sub $dtStart }}
  {{ range $occ := $occurs }}
    {{ $occEnd := $occ.Add $duration }}
    {{ $events = $events | append (dict
        "uid"     $uid
        "summary" $summary
        "desc"    $desc
        "start"   ($fmtDate $occ)
        "end"     ($fmtDate $occEnd)
      ) }}
  {{ end }}

{{ end }}   {{/* end range $ev */}}

{{/* Finally output JSON for the caller */}}
{{ jsonify $events }}
